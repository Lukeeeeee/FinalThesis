\documentclass{standalone}
% preamble: usepackage, etc.
\begin{document}

\chapter{基于搜索的路径规划方法}
在给出路径规划问题的定义后，我们在这一章给出传统的路径规划问题解决方法，从传统的最短路径算法，到近些年较为先进的算法等，最后我们简单分析现有算法的不足。通过将传统方法和基于强化学习的方法对比，可以更好的体现我们算法的创新性和贡献。
\section{Dijkstra 算法}
Dijkstrea 算法由荷兰计算机科学家 Edsger Wybe Dijkstra在1956年提出的单源最短路径算法，在随后的几年内被正式发表\citing{Dijkstra}。
\subsection{算法描述}
首先定义我们起始的点为$v_s$，令$D_{v_j}$表示点$v_j$到初始点 $v_s$的距离。Dijkstra 算法首先赋予一些初始距离值，然后通过迭代计算和优化距离值，算法的基本流程如下。\par
第一步，首先将所有点标记为未访问过，并放入一个未访问的点的集合$Q$中，然后对初始点，设置它的距离值$D$为0，剩余点设置为无穷大。
第二步，从未访问集合$Q$中取出具有最小距离值的点，查询它的邻居节点的距离值，
如果邻居节点通过当前节点后其距离值降低，则更新邻居节点的距离值，这一步操作成为松弛操作。当前节点的所有邻居都被更新后，将当前节点标记为已访问，然后重复第二步，直到未访问集合为空。
第三步，如果目标节点被标记为已访问，则表示我们找到了一条从起点到目标节点的最短路径。
在计算过程中，我们可以对每个点维护一个前驱节点值，即当前节点的距离值被某个邻居节点的距离值更新时，同时更新该前驱值为对应邻居节点。在计算结束后，可以通过该前驱节点值递归的输出最短路径。
\subsection{复杂度分析}
Dijkstra 算法的时间复杂度上下界可使用大$O$符号，由用点集$V$和边集$E$组成的函数表示，时间复杂度的上下界的紧致程度或长数值大小由算法中$Q$集合的实现决定。Dijkstra复杂度为$O(|V|^2)$，其中$|V|$为图中点的数量。但一个更精确的表述为 $O(|E|\cdot T_{dk} + |V|\cdot T_{em})$，其中$T_{dk}$表示完成集合中键的降序排列时间复杂度，$T_{em}$表示从集合中取出最小键值的时间复杂度。
\subsection{Dijkstra的相关改进算法}
在 Dijkstra 算法被提出后，许多基于 Dijkstra 的优化算法被提出。
由于在 Dijkstra 算法中很重要的一步为从$Q$集合中取出具有最小距离值$D$的节点，因此Boas等人提出了基于优先队列实现的改进算法，使得其复杂度降到了$O(|V|loglog|V|)$。
Fredman和 Tarjan通过斐波那契堆实现的算法复杂度为$O(|E| + |V|log|V|)$\citing{Fredman1984Fibonacci}。
\section{Floyd 算法}
Floyd 算法为 Robert Floyd 在1962年提出\citing{Floyd1962Algorithm}，同年代，Warshall 也提出了类似算法，因此该算法又被称为 Floyd-Warshall 算法。Floyd 解决了多源最短路问题，其时间复杂度为$O(|V|^3)$，它通过枚举任意两点之间可能的最短路径然后按照基于动态规划的思想进行更新。
\subsection{算法描述}
设$D_{i,j,k}$表示从顶点$i$ 到顶点$j$的只以$(1..k)$集合中的节点为中间节点的最短路径长度，那么我们可以通过枚举$k \in \{1..|V|\}$，按照如下公式更新$D_{i,j,k}$：\begin{equation}
    D_{i,j,k} = min(D_{i,j,k-1}, D_{i,k,k-1} + D_{k,j,k-1})
\end{equation}

\section{Bellman-Ford 算法}
Dijkstra和 Floyd 算法存在的问题在于无法处理带有负环的图的最短路径问题，即如果在给定的图中，如果存在一个环路，通过该环路的损失为负值，那么理论上可以无限的降低总损失值，因而无法给出正确的最短路径。所以Richard Bellman 和 Lester Ford于1958年年提出了可以处理负环的 Bellman-Ford 算法\citing{Bellman1958On}。
\subsection{算法描述}
与 Dijkstra 算法类似，Bellman-Ford也是基于松弛操作，然而 Dijkstra 是通过贪心的选择距离最小的点进行松弛操作，而后者是简单的通过枚举边然后对边上的两个端点进行松弛操作，这一过程共进行$|V|-1$次，由于任意一个图上的最短路径长度不会超过$|V|-1$。
因此在$|V|-1$次松弛操作后，理论上保证了在解存在情况下，算法能够找到最短路径的解。最后 Bellman-Ford 算法通过第$|V|$次松弛操作，检测是否存在负环，如果在第$|V|$次松弛操作时，仍然存在可被缩小的距离值，那么说明负环存在。
\section{$A^{*}$ 算法}
$A^{*}$ 算法是一类重要的启发式搜索算法\citing{Astar}，它的核心思想在于，通过对搜索的状态空间中的每一个搜索位置按照某一启发式函数进行评估，选择具有最优值的搜索点进行下一步搜索。
由于路径规划问题本质上一个在图上的搜索问题，因此$A^{*}$ 算法也被应用到了该问题中。
\subsection{算法描述}
在$A^{*}$ 算法中，最重要的为设计启发式函数$f(v_i)$，或者成为估算函数。一般函数具有$f(v_i) = g(v_i) + h(v_i)$的形式，其中$g(v_i)$表示从初始点走到 $v_i$的代价值，$h(v_i)$表示从点$v_i$到目标点的估计距离。在实际的算法中，我们会维护关于$g(v_i)$的表，对于$h(v_i)$，我们一般使用欧几里得距离，曼哈顿距离或切比雪夫距离等计算方法作为估算函数。\par
算法的基本流程如下，首先定义集合$C_{set}$为被估算的节点集合，$O_{set}$为将要被估算的节点集合，初始时只包括起点。起点的 $g$函数值为0，$h$函数值设为某一距离函数下的计算结果。当$O_{set}$不为空时，我们取出其中$f$值最小的点$v_{min}$，枚举该点的邻居$v_{neighbor_i}$，如果该点不在$C_{set}$中，根据松弛操作判断$v_{neighbor_i}$的$g$值是否在通过$v_{min}$后更小，如果是，则更新$v_{neighbor_i}$的$g, h, f$值，同时将$v_{neighbor_i}$加入$O_{set}$，如果否，则不做任何更新和操作。最终当我们取出的点$v_{min}$为目标点时，说明我们找到了解。
\subsection{复杂度分析}
$A^{*}$ 算法的复杂度依赖于启发式函数的设计。在最坏情况下，$A^{*}$的复杂度相当于一个不带任何优化和限制的搜索算法的复杂度 $O(b^d)$，其中$b$为状态空间的宽度，即每个搜索状态的后继状态的平均数量，在该问题中为每个节点相临节点的数量，$d$为搜索空间的深度，在该问题中为路径的长度的最大值，即为定点的个数。而一个好的启发式函数可以大大减少搜索状态的数量，特别是$b$的值。作为搜索算法，复杂度的定义显然与搜索节点的数量成正比，因此我们定义 $N$： 
    \begin{equation}
        N + 1 = 1 + b^* + (b^*)^2 + ... + (b^*)^d
    \end{equation}
而最优的启发式函数$h_*(x)$具有$b=1$。对于任意一个非最优的启发式函数，当其启发式函数符合方程\ref{eq3astar}，其时间复杂度为多项式级别。
    \begin{equation}
    \label{eq3astar}
        |h(x) - h_*(x)| = O(logh_*(x))
    \end{equation}
\section{改进算法}
随着交通网络的复杂度提高，基于图的搜索算法难以处理过大的地图，因此一些优化方法便被提出。\par
Thorup 和 Zwick 提出了基于预处理和查询的分步方法\citing{Thorup2001Compact}。这类方法首先离线对原始图进行预处理，降低原问题的复杂度，然后在查询阶段，利用预处理阶段得到的数据和简化后的图快速给出路径规划结果。
第二类改进算法为结构化的最短路径算法，交通网络本身具有一定的结构性质，即分层模型，通过将地图按照一定的规则分层，然后对分层后的模型做路径规划可以提升原有算法的性能。例如 Sanders 和 Schultes 提出了通过定义邻近集合和邻近搜索的方法\citing{Sanders2005Highway, Sanders2006Engineering}，这类方法被称为公路结构化方法（Highway Hierarchies）方法。同样 Geisberger 等人提出了基于缩点的结构化方法\citing{Geisberger2008Contraction}，通过对节点按照重要性排序，然后将非重要的节点进行缩点和替换从而减小图的规模。\par
Delling等人提出了可定制化的最短路径算法\citing{Delling2011Customizable}，他们将图分为静态的拓扑结构，包括了边，节点等，和计算模式，即如何计算行驶损失的方法两部分。使得前者维持静态，后者为一个动态模块。该算法分为三个步骤，首先为独立损失计算部分，在这一步只对静态图进行预处理，第二步为定制化计算损失阶段，对不同的损失计算方法进行处理。最后为查询阶段，根据不同的损失计算方法给出结构。

\section{本章小结}
在本章，我们给出了传统的基于图的搜索算法，包括经典的 Dijkstra 算法和近些年各国学者提出的种种改进算法，但我们也看到了这些算法存在的部分问题。现有的算法，大多是基于不同场景的定制化算法，对于不同的最短路计算函数，需要单独设计不同的算法，这导致不同场景下的算法具有较少的通用性和可扩展性。其次随着交通场景的复杂化和规模增大，现有的改进算法大多基于较为简单的预处理来增加额外的信息和降低图的规模。因此我们将尝试使用强化学习解决这些问题，并为路径规划问题未来的设计和发展提供新的思路。
\end{document}